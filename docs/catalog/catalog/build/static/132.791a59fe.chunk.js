webpackJsonp([132],{799:function(e,t,n){var s=n(15),f=n(45),i=n(286).PageRenderer;i.__esModule&&(i=i.default);var a=f({displayName:"WrappedPageRenderer",getInitialState:function(){return{content:n(956)}},componentWillMount:function(){},render:function(){return s.createElement(i,Object.assign({},this.props,{content:this.state.content}))}});a.__catalog_loader__=!0,e.exports=a},956:function(e,t){e.exports="# About `fs.read()` & `fs.write()`\n\n[`fs.read()`](https://nodejs.org/api/fs.html#fs_fs_read_fd_buffer_offset_length_position_callback) & [`fs.write()`](https://nodejs.org/api/fs.html#fs_fs_write_fd_buffer_offset_length_position_callback) are different from other `fs` methods in that their callbacks are called with 3 arguments instead of the usual 2 arguments.\n\nIf you're using them with callbacks, they will behave as usual. However, their promise usage is a little different. `fs-extra` promisifies these methods like [`util.promisify()`](https://nodejs.org/api/util.html#util_util_promisify_original) (only available in Node 8+) does.\n\nHere's the example promise usage:\n\n## `fs.read()`\n\n```js\n// Basic promises\nfs.read(fd, buffer, offset, length, position)\n  .then(results => {\n    console.log(results)\n    // { bytesRead: 20, buffer: <Buffer 0f 34 5d ...> }\n  })\n\n// Async/await usage:\nasync function example () {\n  const { bytesRead, buffer } = await fs.read(fd, Buffer.alloc(length), offset, length, position)\n}\n```\n\n## `fs.write()`\n\n```js\n// Basic promises\nfs.write(fd, buffer, offset, length, position)\n  .then(results => {\n    console.log(results)\n    // { bytesWritten: 20, buffer: <Buffer 0f 34 5d ...> }\n  })\n\n// Async/await usage:\nasync function example () {\n  const { bytesWritten, buffer } = await fs.write(fd, Buffer.alloc(length), offset, length, position)\n}\n```\n"}});
//# sourceMappingURL=132.791a59fe.chunk.js.map